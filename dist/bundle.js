(()=>{var u=class{constructor(){this._events={},this._counter=0}on(e,t){this._events[e]||(this._events[e]=[]);let s=this._counter++;return this._events[e].push({listener:t,token:s}),s}emit(e,...t){return this._events[e]?(this._events[e].forEach(s=>s.listener(...t)),!0):!1}removeListener(e,t){if(this._events[e]&&t){let s=this._events[e].findIndex(r=>r.token===t);if(s>-1)return this._events[e].splice(s,1),!0}return!1}removeAllListeners(e){return this._events[e]?(delete this._events[e],!0):!1}};var n=class{constructor(e,t){this.key=e,this.storage=t}async get(){throw Error("Not implemented")}async set(e){throw Error("Not implemented")}async remove(){throw Error("Not implemented")}};var h=class extends n{constructor(e){super(e,window?window.localStorage:null)}async get(){return JSON.parse(this.storage.getItem(this.key))}async set(e){return this.storage.setItem(this.key,JSON.stringify(e))}async remove(){return this.storage.removeItem(this.key)}};var f={ADDED:"added",MODIFIED:"modified",REMOVED:"removed"},i={DOCUMENT_CREATED:"DOCUMENT_CREATED",DOCUMENT_REMOVED:"DOCUMENT_REMOVED",DOCUMENT_UPDATED:"DOCUMENT_UPDATED"},a=class{unsubscribeToken=null;constructor(e,t,s,r,o=new h(r)){this.store=o,this.events=new u,this.firestore=e,this.collectionRef=t,this.lastUpdatedField=s}static createFactory(e,t,s,r){if(!(t instanceof n))throw Error("store is not an instance of TimestampStore");return{create(o=s,m=r){return a.create(e,t,o,m)}}}static create(e,t,s,r){return new a(e,s,r,null,t)}onCreated(e){this.events.on(i.DOCUMENT_CREATED,e)}onUpdated(e){this.events.on(i.DOCUMENT_UPDATED,e)}onRemoved(e){this.events.on(i.DOCUMENT_REMOVED,e)}async connect(){let e=await this.getLastSyncTimestamp();return this.addQueryListener(e,t=>{throw t})}disconnect(){this.removeQueryListener()}clearLastSyncTimestamp(){return this.store.remove()}addQueryListener(e,t){return this.unsubscribeToken?(console.warn("Listener is already subscribed."),!1):(this.unsubscribeToken=this.onQuerySnapshot(e,async s=>{try{await this.collectionListenerCallback(s)}catch(r){return t(r)}},t),this.unsubscribeToken)}onQuerySnapshot(e,t,s){return this.collectionRef.where(this.lastUpdatedField,">",e.toDate()).onSnapshot(t,s)}async collectionListenerCallback(e){if(!e)throw Error("No snapshot in windows listener");if(e.metadata.hasPendingWrites)return;let t=e.docChanges(),{ADDED:s,MODIFIED:r}=f;for(let o of t){let{type:m,doc:c}=o,l=c.data();if(await this.updateLastSyncTimestamp(l[this.lastUpdatedField]),m===s){if(l.isDeleted){this.events.emit(i.DOCUMENT_REMOVED,c);continue}this.events.emit(i.DOCUMENT_CREATED,c)}if(m===r){if(l.isDeleted){this.events.emit(i.DOCUMENT_REMOVED,c);continue}this.events.emit(i.DOCUMENT_UPDATED,c)}}}removeQueryListener(){if(!this.unsubscribeToken){console.warn("No unsubcribe token");return}this.unsubscribeToken(),this.unsubscribeToken=null}async getLastSyncTimestamp(){let e=await this.store.get();if(!e)return this.firestore.Timestamp.fromDate(new Date(1990,1,1));let{seconds:t,nanoseconds:s}=e;return new this.firestore.Timestamp(t,s)}async updateLastSyncTimestamp(e){if(!e||typeof e!="object")throw Error("Missing or invalid timestamp data",e);let t=await this.getLastSyncTimestamp(),{seconds:s,nanoseconds:r}=e;return new this.firestore.Timestamp(s,r)<=t?!1:this.store.set(e)}};})();
