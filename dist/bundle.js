(()=>{var T=Object.create;var E=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var b=r=>E(r,"__esModule",{value:!0});var v=r=>{if(typeof require!="undefined")return require(r);throw new Error('Dynamic require of "'+r+'" is not supported')};var M=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of D(e))!w.call(r,s)&&s!=="default"&&E(r,s,{get:()=>e[s],enumerable:!(t=p(e,s))||t.enumerable});return r},O=r=>M(b(E(r!=null?T(y(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var i=O(v("firebase/firestore"));var h=class{constructor(){this.events={},this.counter=0}on(e,t){this.events[e]||(this.events[e]=[]);let s=this.counter++;return this.events[e].push({listener:t,token:s}),s}emit(e,...t){return this.events[e]?(this.events[e].forEach(s=>s.listener(...t)),!0):!1}removeListener(e,t){if(this.events[e]&&t){let s=this.events[e].findIndex(n=>n.token===t);if(s>-1)return this.events[e].splice(s,1),!0}return!1}removeAllListeners(e){return this.events[e]?(delete this.events[e],!0):!1}};var o=class{constructor(e,t){this.key=e,this.storage=t}async get(){throw Error("Not implemented")}async set(e){throw Error("Not implemented")}async remove(){throw Error("Not implemented")}};var l=class extends o{constructor(e){super(e,window?window.localStorage:null)}async get(){return JSON.parse(this.storage.getItem(this.key))}async set(e){return this.storage.setItem(this.key,JSON.stringify(e))}async remove(){return this.storage.removeItem(this.key)}};var S={ADDED:"added",MODIFIED:"modified",REMOVED:"removed"},a={DOCUMENT_CREATED:"DOCUMENT_CREATED",DOCUMENT_REMOVED:"DOCUMENT_REMOVED",DOCUMENT_UPDATED:"DOCUMENT_UPDATED"},c=class{unsubscribeToken=null;constructor(e,t,s,n=new l(s)){this.store=n,this.events=new h,this.collectionRef=e,this.lastUpdatedField=t}static createFactory(e,t,s){if(!(e instanceof o))throw Error("store is not an instance of TimestampStore");return{create(n=t,m=s){return c.create(e,n,m)}}}static create(e,t,s){return new c(t,s,null,e)}onCreated(e){this.events.on(a.DOCUMENT_CREATED,e)}onUpdated(e){this.events.on(a.DOCUMENT_UPDATED,e)}onRemoved(e){this.events.on(a.DOCUMENT_REMOVED,e)}async connect(){let e=await this.getLastSyncTimestamp();return this.addQueryListener(e,t=>{throw t})}disconnect(){this.removeQueryListener()}clearLastSyncTimestamp(){return this.store.remove()}addQueryListener(e,t){return this.unsubscribeToken?(console.warn("Listener is already subscribed."),!1):(this.unsubscribeToken=this.onQuerySnapshot(e,async s=>{try{await this.collectionListenerCallback(s)}catch(n){return t(n)}},t),this.unsubscribeToken)}onQuerySnapshot(e,t,s){return(0,i.onSnapshot)((0,i.query)(this.collectionRef,(0,i.where)(this.lastUpdatedField,">",e.toDate())),t,s)}async collectionListenerCallback(e){if(!e)throw Error("No snapshot in windows listener");if(e.metadata.hasPendingWrites)return;let t=e.docChanges(),{ADDED:s,MODIFIED:n}=S;for(let m of t){let{type:f,doc:u}=m,d=u.data();if(await this.updateLastSyncTimestamp(d[this.lastUpdatedField]),f===s){if(d.isDeleted){this.events.emit(a.DOCUMENT_REMOVED,u);continue}this.events.emit(a.DOCUMENT_CREATED,u)}if(f===n){if(d.isDeleted){this.events.emit(a.DOCUMENT_REMOVED,u);continue}this.events.emit(a.DOCUMENT_UPDATED,u)}}}removeQueryListener(){if(!this.unsubscribeToken){console.warn("No unsubcribe token");return}this.unsubscribeToken(),this.unsubscribeToken=null}async getLastSyncTimestamp(){let e=await this.store.get();if(!e)return i.Timestamp.fromDate(new Date(1990,1,1));let{seconds:t,nanoseconds:s}=e;return new i.Timestamp(t,s)}async updateLastSyncTimestamp(e){if(!e||typeof e!="object")throw Error("Missing or invalid timestamp data",e);let t=await this.getLastSyncTimestamp(),{seconds:s,nanoseconds:n}=e;return new i.Timestamp(s,n)<=t?!1:this.store.set(e)}};})();
